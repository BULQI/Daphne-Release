#pragma once

#include "Nt_ManifoldUtilities.h"

using namespace System;
using namespace System::Collections::Generic;
using namespace System::Security;
using namespace System::Linq;
using namespace System::Text;
using namespace MathNet::Numerics::LinearAlgebra::Double;

namespace Nt_ManifoldRing
{
	ref class ScalarField;
	interface class Interpolator;

    /// <summary>
    /// This puts the responsibility for scalar field multiplication in the manifold class.
    /// We may regard this as the specification of a scalar field handling class.
    /// </summary>
    public ref class Manifold abstract
    {
	private:
		int dim;
	public:
        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="dim">manifold dimension</param>
        Manifold(int dim)
        {
            Id = safeId++;
            Dim = dim;
        }

        /// <summary>
        /// manifold dimension
        /// </summary>
        property int Dim 
		{ 
			int get()
			{
				return dim;
			}
		private:
			void set(int value)
			{
				dim = value;
			}
		}
        /// <summary>
        /// unique id; serves as key
        /// </summary>
        property int Id;

	private:
        static int safeId = 0;

	public:
        /// <summary>
        /// the size of the generated underlying array
        /// </summary>
        property int ArraySize;

	protected:
		//made static here, sine it is not changing over instance.
        static const double E_BOUNDARY_THICKNESS = 0.001;


	public:
        /// <summary>
        /// manifold extent
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>extent as double</returns>
        virtual double Extent(int i) abstract;
        /// <summary>
        /// manifold stepsize
        /// </summary>
        /// <returns>stepsize as double</returns>
        virtual double StepSize() abstract;
        /// <summary>
        /// nodes per side
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>number of nodes as int</returns>
        virtual int NodesPerSide(int i) abstract;
        /// <summary>
        /// initialize manifold members
        /// </summary>
        /// <param name="data">data array</param>
        virtual void Initialize(array<double>^ data) abstract;
        /// <summary>
        /// value at position, delegates to scalar field and interpolates if needed
        /// </summary>
        /// <param name="x">position</param>
        /// <param name="sf">underlying scalar field</param>
        /// <returns>value as double</returns>
        virtual double Value(array<double> ^x, ScalarField^ sf) abstract;
        /// <summary>
        /// calculate and return the mean concentration in this scalar field
        /// </summary>
        /// <param name="sf">scalar field generated by this manifold</param>
        /// <returns>the mean value</returns>
        virtual double MeanValue(ScalarField^ sf) abstract;

	protected:
        /// <summary>
        /// checks if a point in local coordinates is on the manifold
        /// </summary>
        /// <param name="x">the point, assume to be in local coordinates</param>
        /// <returns>true if the point is on the manifold</returns>
        virtual bool localIsOn(array<double>^ x) abstract;

        // operators

	public:
        /// <summary>
        /// scalarfield multiplication
        /// </summary>
        /// <param name="sf1">lh operand</param>
        /// <param name="sf2">rh operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Multiply(ScalarField^ sf1, ScalarField^ sf2) abstract;
        /// <summary>
        /// addition of a constant to a scalar field
        /// </summary>
        /// <param name="sf">scalar field</param>
        /// <param name="d">constant</param>
        /// <returns></returns>
        virtual ScalarField^ Add(ScalarField^ sf, double d) abstract;
        /// <summary>
        /// Laplacian field
        /// </summary>
        /// <param name="sf">field operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Laplacian(ScalarField^ sf) abstract;
        /// <summary>
        /// gradient
        /// </summary>
        /// <param name="x">local position</param>
        /// <param name="sf">field operand</param>
        /// <returns>gradient vector</returns>
        virtual array<double>^ Grad(array<double>^ x, ScalarField^ sf) abstract;

        /// <summary>
        /// field diffusion, flux term
        /// </summary>
        /// <param name="flux">flux involved</param>
        /// <returns>diffusion flux term as field</returns>
        virtual ScalarField^ DiffusionFluxTerm(ScalarField^ flux, Transform^ t, ScalarField^ dst, double dt) abstract;
        /// <summary>
        /// integrate over the whole field
        /// </summary>
        /// <param name="sf">field parameter</param>
        /// <returns>integral value</returns>
        virtual double Integrate(ScalarField^ sf) abstract;
        /// <summary>
        /// manifold length
        /// </summary>
        /// <returns>length as double</returns>
        virtual double Length() abstract;
        /// <summary>
        /// manifold area
        /// </summary>
        /// <returns>area as double</returns>
        virtual double Area() abstract;
        /// <summary>
        /// manifold volume
        /// </summary>
        /// <returns>volume as double</returns>
        virtual double Volume() abstract;
        /// <summary>
        /// manifold voxel volume
        /// </summary>
        /// <returns>voxel volume as double</returns>
        virtual double VoxelVolume() abstract;
        /// <summary>
        /// Restriction of a scalar field to a boundary manifold
        /// </summary>
        /// <param name="from">Scalar field being restricted</param>
        /// <param name="to">Scalar field in restricted space</param>
        /// <returns></returns>
        virtual ScalarField^ Restrict(ScalarField^ from, Transform^ t, ScalarField^ to) abstract;
        /// <summary>
        /// The points on a manifold that are used to exchange flux
        /// </summary>
        property array<Vector^>^ PrincipalPoints;
        /// <summary>
        /// Impose Dirichlet boundary conditions
        /// </summary>
        /// <param name="from">Field specified on the boundary manifold</param>
        /// <param name="t">Transform that specifies the geometric relationship between 
        /// the boundary and interior manifolds </param>
        /// <param name="to">Field specified on the interior manifold</param>
        /// <returns>The field after imposing Dirichlet boundary conditions</returns>
        virtual ScalarField^ DirichletBC(ScalarField^ from, Transform^ t, ScalarField^ to) abstract;
    };

    /// <summary>
    /// base for the ME manifolds
    /// </summary>
    public ref class MomentExpansionManifold abstract: Manifold
    {
	public:
        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="dim">dimension</param>
        MomentExpansionManifold(int dim) : Manifold(dim)
        {
            ArraySize = 4;
            PrincipalPoints = gcnew array<Vector^>(1);
            PrincipalPoints[0] = gcnew DenseVector(3);
        }

        /// <summary>
        /// ME scalarfield multiplication
        /// </summary>
        /// <param name="sf1">lh operand</param>
        /// <param name="sf2">rh operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Multiply(ScalarField^ sf1, ScalarField^ sf2) override;

        /// <summary>
        /// addition of a constant to a ME scalar field
        /// gradient is not changed
        /// </summary>
        /// <param name="sf">ME scalar field</param>
        /// <param name="d">constant</param>
        /// <returns></returns>
        virtual ScalarField^ Add(ScalarField^ sf, double d) override;
            
        /// <summary>
        /// Restriction of a scalar field to an ME boundary manifold
        /// </summary>
        /// <param name="from">scalar field as represented on from.M, the interior manifold</param>
        /// <param name="pos">scalar field as represented on to.M, the boundary manifold</param>
        /// <param name="to">the location of the boundary manifold in the interior manifold</param>
        /// <returns></returns>
        virtual ScalarField^ Restrict(ScalarField^ from, Transform^ t, ScalarField^ to) override;

        virtual ScalarField^ DirichletBC(ScalarField^ from, Transform^ t, ScalarField^ to) override
        {
            throw gcnew NotImplementedException();
        }

        /// <summary>
        /// calculate and return the mean concentration in this scalar field
        /// </summary>
        /// <param name="sf">scalar field generated by this manifold</param>
        /// <returns>the mean value</returns>
        virtual double MeanValue(ScalarField^ sf) override; 

    };

    /// <summary>
    /// tiny sphere manifold
    /// </summary>
    public ref class TinySphere : MomentExpansionManifold
    {
	private:
        double radius;
	protected:
        ScalarField^ laplacian;

	public:
        /// <summary>
        /// constructor
        /// </summary>
        TinySphere();

        /// <summary>
        /// initialize the radius
        /// </summary>
        /// <param name="data">one element array with the radius</param>
        virtual void Initialize(array<double>^ data) override
        {
            if (data->Length != 1)
            {
                throw gcnew Exception("TinySphere Initialize data must have length 1");
            }

            radius = data[0];
        }

        /// <summary>
        /// TinySphere manifold extent
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>extent as double</returns>
        virtual double Extent(int i) override
        {
            if (i < 0 || i > 0)
            {
                throw gcnew Exception("Extent out of range.");
            }

            return radius;
        }

        /// <summary>
        /// TinySphere manifold stepsize
        /// </summary>
        /// <returns>stepsize as double</returns>
        virtual double StepSize() override
        {
            return 0;
        }

        /// <summary>
        /// TinySphere nodes per side
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>number of nodes as int</returns>
        virtual int NodesPerSide(int i) override
        {
            return 0;
        }

        /// <summary>
        /// TinySphere manifold length
        /// </summary>
        /// <returns></returns>
        virtual double Length() override
        {
            return 0;
        }

        /// <summary>
        /// TinySphere manifold area
        /// </summary>
        /// <returns>area as double</returns>
        virtual double Area() override
        {
            return 4 * Math::PI * radius * radius;
        }

        /// <summary>
        /// TinySphere manifold volume
        /// </summary>
        /// <returns>volume as double</returns>
        virtual double Volume() override
        {
            return 0;
        }

        /// <summary>
        /// TinySphere manifold voxel volume
        /// </summary>
        /// <returns>voxel volume as double</returns>
        virtual double VoxelVolume() override
        {
            return 0;
        }

        /// <summary>
        /// TinySphere value at position, delegates to scalar field
        /// </summary>
        /// <param name="x">position</param>
        /// <param name="sf">underlying scalar field</param>
        /// <returns>value as double</returns>
        virtual double Value(array<double>^ x, ScalarField^ sf) override;
		
	protected:
        /// <summary>
        /// checks if a point in local coordinates is on the manifold
        /// </summary>
        /// <param name="x">the point, assume to be in local coordinates</param>
        /// <returns>true if the point is on the manifold</returns>
        virtual bool localIsOn(array<double>^ x) override
        {
            double length = Math::Sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);

            return Math::Abs(length - radius) <= E_BOUNDARY_THICKNESS / 2.0;
        }

	public:
        /// <summary>
        /// TinySphere Laplacian field
        /// </summary>
        /// <param name="sf">field operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Laplacian(ScalarField^ sf) override;

        /// <summary>
        /// TinySphere gradient
        /// </summary>
        /// <param name="x">local position</param>
        /// <param name="sf">field operand</param>
        /// <returns>gradient vector</returns>
        virtual array<double>^ Grad(array<double>^ x, ScalarField^ sf) override;

        /// <summary>
        /// TinySphere field diffusion, flux term
        /// </summary>
        /// <param name="flux">flux involved</param>
        /// <returns>diffusion flux term as field</returns>
        virtual ScalarField^ DiffusionFluxTerm(ScalarField^ flux, Transform^ t, ScalarField^ dst, double dt) override
        {
            throw gcnew NotImplementedException();
        }

        /// <summary>
        /// TinySphere integrate over the whole field
        /// </summary>
        /// <param name="sf">field parameter</param>
        /// <returns>integral value</returns>
        virtual double Integrate(ScalarField^ sf) override;
    };

    /// <summary>
    /// tiny ball manifold
    /// </summary>
    public ref class TinyBall : MomentExpansionManifold
    {
	private:
		double radius;

	protected:
		ScalarField^ diffusionField;
        ScalarField^ laplacian;
        array<double>^ gradient;

	public:
        /// <summary>
        /// constructor
        /// </summary>
        TinyBall();

        /// <summary>
        /// initialize the radius
        /// </summary>
        /// <param name="data">one element array with the radius</param>
        virtual void Initialize(array<double>^ data) override
        {
            if (data->Length != 1)
            {
                throw gcnew Exception("TinyBall Initialize data must have length 1");
            }

            radius = data[0];
        }

        /// <summary>
        /// TinyBall manifold extent
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>extent as double</returns>
        virtual double Extent(int i) override
        {
            if (i < 0 || i > 0)
            {
                throw gcnew Exception("Extent out of range.");
            }

            return radius;
        }

        /// <summary>
        /// TinyBall manifold stepsize
        /// </summary>
        /// <returns>stepsize as double</returns>
        virtual double StepSize() override
        {
            return 0;
        }

        /// <summary>
        /// TinyBall nodes per side
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>number of nodes as int</returns>
        virtual int NodesPerSide(int i) override
        {
            return 0;
        }

        /// <summary>
        /// TinyBall manifold length
        /// </summary>
        /// <returns></returns>
        virtual double Length() override
        {
            return 0;
        }

        /// <summary>
        /// TinyBall manifold area
        /// </summary>
        /// <returns>area as double</returns>
        virtual double Area() override
        {
            return 4 * Math::PI * radius * radius;
        }

        /// <summary>
        /// TinyBall manifold volume
        /// </summary>
        /// <returns>volume as double</returns>
        virtual double Volume() override
        {
            return 4.0 / 3.0 * Math::PI * radius * radius * radius;
        }

        /// <summary>
        /// TinyBall manifold voxel volume
        /// </summary>
        /// <returns>voxel volume as double</returns>
        virtual double VoxelVolume() override
        {
            return 0;
        }

        /// <summary>
        /// TinyBall value at position, delegates to scalar field
        /// </summary>
        /// <param name="x">position</param>
        /// <param name="sf">underlying scalar field</param>
        /// <returns>value as double</returns>
        virtual double Value(array<double>^ x, ScalarField^ sf) override; 

	protected:
        /// <summary>
        /// checks if a point in local coordinates is on the manifold
        /// </summary>
        /// <param name="x">the point, assume to be in local coordinates</param>
        /// <returns>true if the point is on the manifold</returns>
        virtual bool localIsOn(array<double>^ x) override
        {
            double length = Math::Sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);

            return length <= radius;
        }

	public:
        /// <summary>
        /// TinyBall Laplacian field
        /// Contributions from boundary terms must be applied separately through flux update.
        /// </summary>
        /// <param name="sf">field operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Laplacian(ScalarField^ sf) override;

        /// <summary>
        /// TinyBall gradient
        /// </summary>
        /// <param name="x">local position</param>
        /// <param name="sf">field operand</param>
        /// <returns>gradient vector</returns>
        virtual array<double>^ Grad(array<double>^ x, ScalarField^ sf) override;

        /// <summary>
        /// TinyBall field diffusion, flux term
        /// The flux scalar field has already been divided by the diffusion coefficient in the boundary reaction Step() method.
        /// </summary>
        /// <param name="flux">flux involved</param>
        /// <param name="t">Transform - not used</param>
        /// <returns>diffusion flux term as field</returns>
        virtual ScalarField^ DiffusionFluxTerm(ScalarField^ flux, Transform^ t, ScalarField^ dst, double dt) override;


        /// <summary>
        /// TinyBall integrate over the whole field
        /// </summary>
        /// <param name="sf">field parameter</param>
        /// <returns>integral value</returns>
        virtual double Integrate(ScalarField^ sf) override;
    };

    /// <summary>
    /// interpolated lattice base
    /// </summary>
    public ref class InterpolatedNodes abstract: Manifold
    {
	protected:
        array<int>^ nNodesPerSide;
        double stepSize;
        array<double>^ extent;
        Interpolator^ interpolator;

	public:
        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="dim">dimension</param>
        /// <param name="interpolator">handle to the interpolator instance used</param>
        InterpolatedNodes(int dim, Interpolator^ interpolator)
            : Manifold(dim)
        {
            this->interpolator = interpolator;
        }

        /// <summary>
        /// initialize the nodes per side and stepsize members
        /// </summary>
        /// <param name="data">data array with dim + 2 entries</param>
        virtual void Initialize(array<double>^ data) override;

        /// <summary>
        /// IL manifold extent
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>extent as double</returns>
        virtual double Extent(int i) override
        {
            if (i < 0 || i > extent->Length - 1)
            {
                throw gcnew Exception("Extent out of range.");
            }

            return extent[i];
        }

        /// <summary>
        /// IL manifold stepsize
        /// </summary>
        /// <returns>stepsize as double</returns>
        virtual double StepSize() override
        {
            return stepSize;
        }

        /// <summary>
        /// IL nodes per side
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>number of nodes as int</returns>
        virtual int NodesPerSide(int i) override
        {
            if (i < 0 || i > nNodesPerSide->Length - 1)
            {
                throw gcnew Exception("NodesPerSide out of range.");
            }

            return nNodesPerSide[i];
        }

        /// <summary>
        /// IL scalarfield multiplication
        /// </summary>
        /// <param name="sf1">lh operand</param>
        /// <param name="sf2">rh operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Multiply(ScalarField^ sf1, ScalarField^ sf2) override;

        /// <summary>
        /// addition of a constant to interpolated nodes scalar field
        /// </summary>
        /// <param name="sf">interpolated nodes scalar field</param>
        /// <param name="d">constant</param>
        /// <returns></returns>
        virtual ScalarField^ Add(ScalarField^ sf, double d) override;

        /// <summary>
        /// local point to multidimensional index
        /// </summary>
        /// <param name="x">local point</param>
        /// <returns>index array</returns>
        array<int>^ localToIndexArray(Vector^ x)
		{
			array<int>^ tmp = gcnew array<int>(Dim);

			for (int i = 0; i < Dim; i++)
			{
				tmp[i] = (int)(x[i] / stepSize);
			}

			return tmp;
		}
        /// <summary>
        /// multidimensional index to local point
        /// </summary>
        /// <param name="idx">index array</param>
        /// <returns>local point</returns>
        Vector^ indexArrayToLocal(array<int>^ idx)
        {
            Vector^ tmp = gcnew DenseVector(Transform::Dim);

            for (int i = 0; i < Dim; i++)
            {
                tmp[i] = idx[i] * stepSize;
            }

            return tmp;
        }

        /// <summary>
        /// multidimensional index to linear index
        /// </summary>
        /// <param name="idx">multidimensional index</param>
        /// <returns>linear index</returns>
        int indexArrayToLinearIndex(array<int>^ idx)
        {
            int lin = 0;

            if (idx->Length <= 0 || idx->Length > Dim)
            {
                throw gcnew Exception("Index dimension doesn't match manifold.");
            }

            lin = idx[0];
            if (idx->Length >= 2)
            {
                lin += idx[1] * nNodesPerSide[0];
                if (idx->Length == 3)
                {
                    lin += idx[2] * nNodesPerSide[0] * nNodesPerSide[1];
                }
                else
                {
                    throw gcnew Exception("Manifold and index dimension larger than three.");
                }
            }

            return lin;
        }

        /// <summary>
        /// linear index to multidimensional index
        /// </summary>
        /// <param name="lin">linear index</param>
        /// <returns>multidimensional index</returns>
        array<int>^ linearIndexToIndexArray(int lin)
        {
            array<int>^ idx = gcnew array<int>(Dim);

            if (Dim >= 1)
            {
                if (Dim >= 2)
                {
                    if (Dim == 3)
                    {
                        idx[2] = lin / (nNodesPerSide[0] * nNodesPerSide[1]);
                        lin %= nNodesPerSide[0] * nNodesPerSide[1];
                    }
                    idx[1] = lin / nNodesPerSide[0];
                    lin %= nNodesPerSide[0];
                }
                idx[0] = lin;
            }

            return idx;
        }

        /// <summary>
        /// linear index to local point
        /// </summary>
        /// <param name="lin">linear index</param>
        /// <returns>local point</returns>
        //public Vector linearIndexToLocal(int lin)
        array<double>^ linearIndexToLocal(int lin)
        {
            //return indexArrayToLocal(linearIndexToIndexArray(lin));
            return indexArrayToLocal(linearIndexToIndexArray(lin))->ToArray();
        }

	protected:
        /// <summary>
        /// checks if a point in local coordinates is on the manifold
        /// </summary>
        /// <param name="x">the point, assume to be in local coordinates</param>
        /// <returns>true if the point is on the manifold</returns>
        virtual bool localIsOn(array<double>^ x) override
        {
            for (int i = Dim; i < Transform::Dim; i++)
            {
                if (x[i] != 0)
                {
                    return false;
                }
            }
            for (int i = 0; i < Dim; i++)
            {
                if (x[i] < 0 || x[i] > extent[i])
                {
                    return false;
                }
            }
            return true;
        }


	public:
        /// <summary>
        /// IL value at position, delegates to scalar field and interpolates
        /// </summary>
        /// <param name="x">position</param>
        /// <param name="sf">underlying scalar field</param>
        /// <returns>value as double</returns>
        virtual double Value(array<double>^ x, ScalarField^ sf) override;


        /// <summary>
        /// calculate and return the mean concentration in this scalar field
        /// </summary>
        /// <param name="sf">scalar field generated by this manifold</param>
        /// <returns>the mean value</returns>
        virtual double MeanValue(ScalarField^ sf) override;

        /// <summary>
        /// IL Laplacian field
        /// </summary>
        /// <param name="sf">field operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Laplacian(ScalarField^ sf) override;

        /// <summary>
        /// IL gradient
        /// </summary>
        /// <param name="x">local position</param>
        /// <param name="sf">field operand</param>
        /// <returns>gradient vector</returns>
        virtual array<double>^ Grad(array<double>^ x, ScalarField^ sf) override;



        /// <summary>
        /// Restriction of a scalar field to an IL boundary manifold
        /// </summary>
        /// <param name="from">scalar field as represented on from.M, the interior manifold</param>
        /// <param name="t">Transform that defines spatial relation between from and to</param>
        /// <param name="to">the location of the boundary manifold in the interior manifold</param>
        /// <returns></returns>
        virtual ScalarField^ Restrict(ScalarField^ from, Transform^ t, ScalarField^ to) override;


        virtual ScalarField^ DiffusionFluxTerm(ScalarField^ flux, Transform^ t, ScalarField^ sf, double dt) override;


        /// <summary>
        /// Impose Dirichlet boundary conditions
        /// </summary>
        /// <param name="from">Field specified on the boundary manifold</param>
        /// <param name="t">Transform that specifies the geometric relationship between 
        /// the boundary and interior manifolds </param>
        /// <param name="to">Field specified on the interior manifold</param>
        /// <returns>The field after imposing Dirichlet boundary conditions</returns>
        virtual ScalarField^ DirichletBC(ScalarField^ from, Transform^ t, ScalarField^ to) override;

    };

    /// <summary>
    /// IL line
    /// </summary>
    public ref class InterpolatedLine : InterpolatedNodes
    {
	public:
        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="interpolator">handle to the interpolator instance used</param>
        InterpolatedLine(Interpolator^ interpolator)
            : InterpolatedNodes(1, interpolator)
        {
        }

        /// <summary>
        /// IL line manifold length
        /// </summary>
        /// <returns></returns>
        virtual double Length() override
        {
            return extent[0];
        }

        /// <summary>
        /// IL line manifold area
        /// </summary>
        /// <returns>area as double</returns>
        virtual double Area() override
        {
            return 0;
        }

        /// <summary>
        /// IL line manifold volume
        /// </summary>
        /// <returns>volume as double</returns>
        virtual double Volume() override
        {
            return 0;
        }

        /// <summary>
        /// IL line manifold voxel volume
        /// </summary>
        /// <returns>voxel volume as double</returns>
        virtual double VoxelVolume() override
        {
            return 0;
        }

        /// <summary>
        /// IL line integrate over the whole field
        /// </summary>
        /// <param name="sf">field parameter</param>
        /// <returns>integral value</returns>
        virtual double Integrate(ScalarField^ sf) override;
    };

    /// <summary>
    /// IL rectangle
    /// </summary>
    public ref class InterpolatedRectangle : InterpolatedNodes
    {
	public:
        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="interpolator">handle to the interpolator instance used</param>
        InterpolatedRectangle(Interpolator^ interpolator)
            : InterpolatedNodes(2, interpolator)
        {
        }

        /// <summary>
        /// IL rectangle manifold length
        /// </summary>
        /// <returns></returns>
        virtual double Length() override
        {
            return 0;
        }

        /// <summary>
        /// IL rectangle manifold area
        /// </summary>
        /// <returns>area as double</returns>
        virtual double Area() override
        {
            return extent[0] * extent[1];
        }

        /// <summary>
        /// IL rectangle manifold volume
        /// </summary>
        /// <returns>volume as double</returns>
        virtual double Volume() override
        {
            return 0;
        }

        /// <summary>
        /// IL rectangle manifold voxel volume
        /// </summary>
        /// <returns>voxel volume as double</returns>
        virtual double VoxelVolume() override
        {
            return 0;
        }

        /// <summary>
        /// IL rectangle integrate over the whole field
        /// </summary>
        /// <param name="sf">field parameter</param>
        /// <returns>integral value</returns>
        virtual double Integrate(ScalarField^ sf) override;
    };

    /// <summary>
    /// IL prism
    /// </summary>
    public ref class InterpolatedRectangularPrism : InterpolatedNodes
    {
	public:
        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="interpolator">handle to the interpolator instance used</param>
        InterpolatedRectangularPrism(Interpolator^ interpolator)
            : InterpolatedNodes(3, interpolator)
        {
        }

        /// <summary>
        /// IL prism manifold length
        /// </summary>
        /// <returns></returns>
        virtual double Length() override
        {
            return 0;
        }

        /// <summary>
        /// IL prism manifold area
        /// </summary>
        /// <returns>area as double</returns>
        virtual double Area() override
        {
            return extent[0] * extent[1] * 2 + extent[1] * extent[2] * 2 + extent[2] * extent[0] * 2;
        }

        /// <summary>
        /// IL prism manifold volume
        /// </summary>
        /// <returns>volume as double</returns>
        virtual double Volume() override
        {
            return extent[0] * extent[1] * extent[2];
        }

        /// <summary>
        /// IL prism manifold voxel volume
        /// </summary>
        /// <returns>voxel volume as double</returns>
        virtual double VoxelVolume() override
        {
            return stepSize * stepSize * stepSize;
        }

        /// <summary>
        /// IL prism integrate over the whole field
        /// </summary>
        /// <param name="sf">field parameter</param>
        /// <returns>integral value</returns>
        virtual double Integrate(ScalarField^ sf) override;
    };

    /// <summary>
    /// A point manifold with no spatial extent.
    /// </summary>
    public ref class PointManifold : Manifold
    {
	public:
        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="dim">manifold dimension</param>
        PointManifold()
            : Manifold(0)
        {
            ArraySize = 1;
            PrincipalPoints = gcnew array<DenseVector^>(1);
            PrincipalPoints[0] = gcnew DenseVector(3);
        }

        /// <summary>
        /// manifold extent
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>extent as double</returns>
        virtual double Extent(int i) override
        {
            return 0;
        }

        /// <summary>
        /// manifold stepsize
        /// </summary>
        /// <returns>stepsize as double</returns>
        virtual double StepSize() override
        {
            return 0;
        }

        /// <summary>
        /// nodes per side
        /// </summary>
        /// <param name="i">direction index</param>
        /// <returns>number of nodes as int</returns>
        virtual int NodesPerSide(int i) override
        {
            return 0;
        }

        /// <summary>
        /// initialize manifold members
        /// </summary>
        /// <param name="data">data array</param>
        virtual void Initialize(array<double>^ data) override
        {
            // no initialization needed
            return;
        }

        /// <summary>
        /// value at position, delegates to scalar field 
        /// </summary>
        /// <param name="x">position</param>
        /// <param name="sf">underlying scalar field</param>
        /// <returns>value as double</returns>
        virtual double Value(array<double>^ x, ScalarField^ sf) override;


        /// <summary>
        /// calculate and return the mean concentration in this scalar field
        /// </summary>
        /// <param name="sf">scalar field generated by this manifold</param>
        /// <returns>the mean value</returns>
        virtual double MeanValue(ScalarField^ sf) override;


	protected:
        /// <summary>
        /// checks if a point in local coordinates is on the manifold
        /// a point is on the PointManifold if it is "close enough" to the origin
        /// </summary>
        /// <param name="x">the point, assume to be in local coordinates</param>
        /// <returns>true if the point is on the manifold</returns>
        virtual bool localIsOn(array<double>^ x) override
        {
            return Math::Abs(x[0]) <= E_BOUNDARY_THICKNESS / 2.0;
        }

	public:

        // operators

        /// <summary>
        /// scalarfield multiplication
        /// </summary>
        /// <param name="sf1">lh operand</param>
        /// <param name="sf2">rh operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Multiply(ScalarField^ sf1, ScalarField^ sf2) override; 

        /// <summary>
        /// addition of a constant to a point manifold
        /// </summary>
        /// <param name="sf">point manifold scalar field</param>
        /// <param name="d">constant</param>
        /// <returns></returns>
        virtual ScalarField^ Add(ScalarField^ sf, double d) override;

        /// <summary>
        /// Laplacian field
        /// </summary>
        /// <param name="sf">field operand</param>
        /// <returns>resulting field</returns>
        virtual ScalarField^ Laplacian(ScalarField^ sf) override;

        /// <summary>
        /// gradient
        /// </summary>
        /// <param name="x">local position</param>
        /// <param name="sf">field operand</param>
        /// <returns>gradient vector</returns>
        virtual array<double>^ Grad(array<double>^ x, ScalarField^ sf) override;

        /// <summary>
        /// field diffusion, flux term
        /// </summary>
        /// <param name="flux">flux involved</param>
        /// <returns>diffusion flux term as field</returns>
        virtual ScalarField^ DiffusionFluxTerm(ScalarField^ flux, Transform^ t, ScalarField^ dst, double dt) override;

        /// <summary>
        /// integrate over the whole field
        /// </summary>
        /// <param name="sf">field parameter</param>
        /// <returns>integral value</returns>
        virtual double Integrate(ScalarField^ sf) override;

        /// <summary>
        /// manifold length
        /// </summary>
        /// <returns></returns>
        virtual double Length() override
        {
            return 0;
        }

        /// <summary>
        /// manifold area
        /// </summary>
        /// <returns>area as double</returns>
        virtual double Area() override
        {
            return 0;
        }

        /// <summary>
        /// manifold volume
        /// </summary>
        /// <returns>volume as double</returns>
        virtual double Volume() override
        {
            return 0;
        }

        /// <summary>
        /// manifold voxel volume
        /// </summary>
        /// <returns>voxel volume as double</returns>
        virtual double VoxelVolume() override
        {
            return 0;
        }

        /// <summary>
        /// Restriction of a scalar field to the PointManifold
        /// </summary>
        /// <param name="from">Scalar field being restricted</param>
        /// <param name="to">Scalar field in restricted space</param>
        /// <returns></returns>
        virtual ScalarField^ Restrict(ScalarField^ from, Transform^ t, ScalarField^ to) override;

        /// <summary>
        /// Impose Dirichlet boundary conditions
        /// </summary>
        /// <param name="from">Field specified on the boundary manifold</param>
        /// <param name="t">Transform that specifies the geometric relationship between 
        /// the boundary and interior manifolds </param>
        /// <param name="to">Field specified on the interior manifold</param>
        /// <returns>The field after imposing Dirichlet boundary conditions</returns>
        virtual ScalarField^ DirichletBC(ScalarField^ from, Transform^ t, ScalarField^ to) override
        {
            throw gcnew Exception("DirichletBC not implemented for PointManifold fields");
        }
    };
}
